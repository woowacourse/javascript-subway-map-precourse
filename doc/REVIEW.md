안녕하세요. 프리코스 참가자 김승원입니다. 올해 중 가장 시간이 빨리 지나갔던 순간이네요! 보통 여유있게 제출을 하는 편인데,
이번 미션은 난이도도 있었고, 피드백과 요구사항을 최대한 반영할 생각에 많이 늦어졌네요...

[3주차 미션 실행 링크는 여기에](https://loquemedalagana.github.io/javascript-subway-map-precourse/) 있습니다!

[프리코스 후기는 여기에](https://blog.naver.com/kodewithamy/222174642068) 있습니다!

## 3주차에서 배운 것들
#### 1. MVC 패턴과 구조화
지난 주 비즈니스 로직과 UI로직을 분리해라는 피드백을 읽자마자 MVC패턴이 떠올랐습니다. 
바로 폴더 구조를 짜기 시작했고, controller 부분을 더 세분화 했습니다.
input / delete 유효성 체크(checkValidation), 유저가 조작하는 부분(action), 조작된 데이터를 로컬 스토리지에 저장하는 부분(reducer). 
이 세가지로 나눴습니다. Model은 다른 분들과 달리 Section을 추가했는데 그 이유는 아래에 후술하겠습니다.

<br/>

#### 2. 로컬 스토리지 활용
새로고침 시 데이터가 날아갈 때 로컬 스토리지를 활용하면 유지할 수 있다는 개념을 배웠습니다. 
단, 저장 시에는 string: string 형태여야 하기 때문에 reducer에서 json.stringify / json.parse를 활용했습니다.
json.parse 할 시 주의해야 할 점은 원활한 노선 데이터 조작을 위해서 함수가 내장된 클래스로 형변환을 해야했다는 것입니다. 
json 형식이 원래 텍스트 형태라는 것을 알게 되었고, 나중에 다른 프로젝트들을 할 시에도 유용할 것 같습니다.

추가로, **로컬 스토리지일 경우 임시저장, 자동로그인 구현 시 응용이 가능할 것 같습니다.** 단 보안은 신경써야겠죠..

만일 자동 로그인을 구현한다면 토큰을 생성해서 로컬 스토리지에 저장 후 오랜 기간 로그인을 안할 시 토큰이 만료되게 하면 되겠네요.

<br/>

#### 3. addEventListener를 더 깔끔하게 구현할 수 있는 방법
위에서 언급한대로 action을 활용했습니다. action에서 유효성 체크를 할 때 try catch를 쓸려다가, 
Promise 객체를 활용하는 것이 더 깔끔할 거 같아서 Promise를 썼습니다. 
성공하면 reducer로 넘어가서 데이터 업데이트, 실패하면 reject로 빠져나가게 구현했습니다.
또한, ui에 이벤트 리스너를 등록해야 하기 때문에 React로 개발할 때처럼 태그별로 커스텀 컴포넌트를 만들었습니다. 
**커스텀 컴포넌트를 생성 시 생성자에다가 이벤트 리스너를 등록하는 함수를 넣어서 사소한 문법이 아닌 비즈니스 로직에만 집중할 수 있도록 했습니다.**

[참고 Button.js]

``` javascript
import { getComponentIdOrClassQuerySelectorName } from "../common/utils.js";

export default class Button {
  constructor(querySelector, buttonInnerText, callbackFunction) {
    const identifier = getComponentIdOrClassQuerySelectorName(querySelector);
    const isDeleteButton = querySelector.charAt(0) === ".";
    this.element = document.createElement("button");
    this.element.id = !isDeleteButton ? identifier : null;
    this.element.innerText = buttonInnerText;
    this.element.onclick = callbackFunction;
    if (isDeleteButton) this.element.classList.add(identifier); // 이 부분
  }

  render() {
    return this.element.outerHTML;
  }
}
```

<br/>

#### 4. 커스텀 컴포넌트 -> innerHTML/outerHTML vs appendChild/removeChild
가장 고민을 많이 해 본 부분 중 하나입니다. React 에서 jss 코드가 전자랑 비슷해서 전자로 할려고 했습니다.
하지만 이벤트를 등록할 때 적용이 되지 않아서 후자로 바꿨습니다. 
컴포넌트 클래스에서 이벤트를 등록한 후 부모 컴포넌트에 적용해주면 불필요하게 이벤트 리스너를 등록하는 코드가 생략 가능합니다.

하지만 innerHTML, outerHTML 역시 필요에 따라 적용했습니다. 정적인 요소에서는 더 깔끔하기 때문입니다.

React나 Vue 에서는 라이브러리 내에서 DOM을 알아서 조작해주겠지만, Vanilla 에서는 직접 DOM을 함수를 통해 조작하는 것이 안전했습니다.

<br/>

#### 5. action 유효성 체크는 주제별로 리팩토링하기
이미 비즈니스 로직을 action으로 주제별로 분류했기 때문에 input 유효성 검사 역시 주제별로 분리했습니다.
2주차때 이미 클래스 형태로 input 유효성 체크를 한 후 성공하면 성공결과 리턴, 실패하면 경고메시지를 출력을 했는데,
이번 미션에서는 해당 개념을 연장했습니다. 기존에 하고 있는 프로젝트 코드에도 input 유효성 검사하는 클래스를 분리해서 리팩토링도 진행했습니다.

<br/>

#### 6. 클래스 상속
제가 개발 공부를 시작한 후 처음으로 시도한 개념입니다. 사실 전공자로써 부끄럽습니다. 상속을 시도한 이유는 코드를 일단 줄이기 위해서입니다.
상속으로 해결 가능한 경우는 서브클래스를 만들어서 생성자 함수가 더 길어지지 못하게 했습니다. 첫 시도 때 Section 이라는 모델을 만들었습니다.
그 이유는 구간 유효성 체크 메소드를 구현하다가 생성자 함수가 15라인을 넘어가서였습니다.

**익숙해진 후에는 주제별로 분리되었던 Table 컴포넌트를 하나로 합쳤습니다. 로컬 스토리지 데이터 변경 후 업데이트를 용이하게 하기 위해서입니다.**

<br/>

#### 7. lodash (배포 시)
이 부분은 깃헙 페이지에 배포했는데 자바스크립트 파일이 로딩이 안되서 원인을 찾아보니 폴더명 앞에 lodash가 있어서였습니다.
프리코스에서 lodash 라이브러리 사용을 금지해서 미션 마무리 단계에서 그냥 폴더명을 변경하니 웹에서도 잘 돌아갑니다.

<br/>

#### 8. 생각지도 못한 오류 (연속으로 2개 역 삭제 시 기존 로컬 스토리지가 undefined로 저장)
알고 보니 배열 조작 메소드의 잘못된 활용(사실상 오타)가 원인이었습니다. 이번 미션은 이전 미션들보다 훨씬 복잡한 구조를 가지고 있기 때문에
구현, 요구사항 준수만큼 집중력 유지도 중요했습니다. 중간에 체력이 떨어져서 메소드 분리를 잘못했었나 봅니다.

<br/>

#### 9. 아쉬운 점
로컬스토리지에서 데이터를 불러온 후 프로그램에 맞게 가공할 때 수시로 변하는 상태에 맞춰줘야 하기 때문에 selector를 호출해서 분류하는 부분이 불필요하게 중복된 거 같아 아쉽습니다.
또한 이전에 클래스 상속에 익숙했다면 View 코드들이 더 깔끔해지지 않았을까 합니다. 미션을 진행하면서 해당 개념을 새로 공부했기 때문에 설계 시에는 이 부분을 고려를 못했습니다.

<hr />

## 프리코스 전체 회고
#### 1. class에 대한 울렁증 극복
이번 프리코스에서 가장 크게 얻은 것은 class에 익숙해진 것입니다. 전공자지만 c언어로만 알고리즘을 풀었고, 클래스에 대해 배운게 c++ 수업시간에
대충 본 것이 다였습니다. java는 학부에서 개설되지 않아 제대로 공부해보지 못했습니다. 따라서 class에 울렁증이 있었고, 알고리즘 풀 때도
class 대신 struct를 사용하였습니다. React를 독학으로 했지만, 클래스형 컴포넌트도 초반에 공부하는게 맞는데 울렁증 때문에 그냥 넘겼습니다.

3번의 미션을 진행하면서 느낀 점은 class를 강제적으로 사용하게끔 해서 어쩔 수 없이 처음부터 공부하기 시작했습니다. 울렁증이 발목을 잡았던 것인지,
기존에 c++로 알고리즘 풀 때 시뮬레이션 유형에서 이미 해당 개념을 적용을 했었던 기억이 나네요. 클래스의 기본을 익혔으면 상속을 공부해야 합니다.

알고리즘 문제풀이에선 상속까지 쓸 일은 없으니 당연히 넘겼습니다. React로 개발할 때도 함수형만 쓰다 보니 상속을 익힐 기회가 없었습니다.
2주차 미션 때 상속을 썼으면 더욱 깔끔한 코드가 되었을 거 같았지만, 상속의 개념을 제대로 이해하지 못해서 이 부분은 그냥 뒀습니다.

3주차 때는 상속을 쓰지 않으면 코드량이 지나치게 길어집니다. 상속을 공부해서 적용해보니 class가 정말 편한 기능임을 느꼈습니다. 이제는 
React에서 클래스형 컴포넌트를 써야할 순간이 온다면 자신감 있게 쓸 수 있을거 같습니다. 비록 프론트앤드로 개발자 커리어를 시작하지만,
추후 java를 공부할 일이 있을 때, c++로 상속을 구현해야 할 일이 있을때도 좋은 토대가 될 것이라는 확신이 들어 기쁩니다.

<br/>

#### 2. README 사용법
보통 깃헙을 private로 사용하는지라 여기에 신경을 안 쓰고 마구잡이로 적었습니다. 기능 구현 목록을 복잡하게(?) 적는 것부터 시작해서, 나중에 변동될 수도 있으니 기능별로 간단하게 적는 식으로 바꿨습니다.
단, 예외 사항들은 아래에 개발 일기 형태로 적었습니다. 나중에 이 저장소를 봤을 때 어떤 부분에서 제가 고민을 했는지 체크할 수도 있기 때문입니다. 
또한 다른 분들이 저장소를 보자마자 제가 어려워하는 부분을 참고하실 수 있도록 하기 위해서입니다. 물론 업무에서는 개발 일기를 README에 쓰면 안될 것이라는 점은 알고 있습니다.


#### 3. 뇌가 달라진 경험
독학으로 웹 프론트를 공부할 때 너무 막막했습니다. 내가 잘 하고 있는 것이 맞는지 의심됐구요. 코드도 더러워지고 몇번을 엎었던 기억이 나네요.
또한 모듈화를 잘못해서 고생했던 기억도 나구요. 코딩 스타일도 내맘대로였습니다. 반드시 알아야 하는 기본적인 내용도 귀찮다고 넘어가기도 했습니다.
이번에 프리코스를 진행하면서 **이전에 프로젝트 하면서 독학으로 익힌 내용들은 다 잊고, 시키는 대로 하는데 집중했습니다.**
그러고 나서 기존 프로젝트 코드를 보니 독학의 한계를 느꼈으며, 어떤 부분에서 잘못 공부했는지 눈에 들어오고 있습니다.
다시 프로젝트로 돌아갈 때, 예전에 짤 당시와 달라진 뇌 구조를 느끼면서 보람을 느끼고 있습니다.



## 우테코 4기를 준비하시는 분들께...
아시다시피 일방적 강의를 통한 학습이 아닙니다. 하지만 주어지는 과제들이 개발실력 향상시키기 좋은 문제들입니다.
제약사항 때문에 강제로 새로운 개념이나 어설프게 알던 개념을 공부해야 합니다. 이번 기수 다른 참가자분은 자바스크립트 인강을 다시 1회독 하셨다고 합니다.
저 같은 경우 강의 체질이 아니다 보니 기본서를 많이 참조했습니다.

개발 뿐만 아니라 어떤 공부든 자기주도적으로 학습할 때 가장 오래 기억이 남습니다. "학"을 하면 "습"을 해야 본인 것이 되기 때문입니다.
우테코 프리코스는 "습"을 하기에 정말 좋은 환경이었습니다. 제한된 시간 안에 제약사항을 지키면서 코딩하면서 스스로 가이드를 잡기 때문입니다.
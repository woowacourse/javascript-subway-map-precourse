## 개발 과정

### day 1
1. 디렉토리 구조 설계
- 데이터 모델링은 models, **인풋/삭제 유효성 체크는 controllers**, 공통 변수는 common
- ui는 views, 그리고 user 인풋 처리는 action / 데이터 저장은 reducer에서 함

### day 2
1. UI 로직 구현 part 1 => 매뉴 버튼 생성
- [참고, insert adjacent html](https://developer.mozilla.org/ko/docs/Web/API/Element/insertAdjacentHTML)

2. document.createElement를 변수로 저장할 때 조심하자
3. 매뉴에 해당하는 tab부터 렌더링하는 이벤트 완료
- 컴포넌트 클래스 생성자 사용, add event listener기능을 클래스 내장함수로 사용
- 콜백 함수는 action폴더에 따로 분류

- 저번에 기능 목록 구현을 지나치게 상세하게 썼는데 이번엔 간략화해서 기능별로 정리함
- 이번 미션은, UI로직과 비즈니스 로직 확실하게 구분하는데 목표를 둠
- 이제 UI로직까지는 대략적으로 짰으므로, 이제 비즈니스 로직(데이터 모델링, user action, store등)에 신경쓰면 됨.

### day 3
1. 인풋을 위한 view 재검토하기
- 주의사항 innerHTML은 함수가 아니라 안에 string을 대입하는 것이다.

2. 생각보다 UI로직에서 시간이 많이 걸렸다. 이것만 하는데 이틀은 쓴거같다ㅠ
- 그 이유는 이벤트 리스너 등록 과정에서 비동기 처리 때문.. 이 아니었다 중요한 것은...

3. 일단 input 성공적으로 되는 것까지는 확인했다.
- 가상 돔을 직접 만들 시, 템플릿 리터럴로 html을 삽입하는 방법이랑 dom 조작함수를 이용하는 방법 두 가지가 있는데,
- 하나로 쓸거면 하나로 쭉 밀고나가는게 좋다.
- 리액트에 익숙한 관계로 둘 다 짬뽕하다가 로직이 꼬여서 시간을 많이 썼다ㅠㅠ

4. 이제 인풋 유효성 검사랑 로컬 스토리지 데이터 모델링 하자!

### day 4
[dataset 사용법](https://javascript.info/dom-attributes-and-properties#non-standard-attributes-dataset)

1. input 유효성 체크 시, 결과를 리턴하는 클래스 선언 후 promise 리턴. 성공하면 resolve 후 다음 순서(스토리지 저장 진행),
   실패 시 오류 메시지 alert창에 출력

2. 데이터 모델은, 우선 역 명은 그냥 string배열로 저장하는게 더 간결해 보여서 삭제함.

3. 로컬 스토리지에서 데이터를 가져올 때는 selector, 업데이트된 데이터를 로컬 스토리지에 저장할 땐 reducer 함수 사용

4. css를 로딩 후 js파일에서 렌더링하게 구현

5. 데이터 모델링은 생각보다 단순했지만 요구사항에 맞게 구현하는게 많이 까다롭다 흑

6. 구현하면서 모듈화...! 또 모듈화!!
- tab(매뉴) 데이터 출력하는 컴포넌트 내에 새로운 열 추가하는 메소드 [역이름, 삭제버튼], [노선이름, 기점, 종점, 삭제버튼] etc
    - 재사용성을 위해 2차원 배열로 리턴이 된다. 그래서 삽입 시에는 구조분해할당으로 첫 원소만 따내서 삽입
- table 컴포넌트 폴더 내에 위에서 뽑아온 데이터 1열을 tr 코드로 변환시켜준다.

7. [경고 메시지??](https://stackoverflow.com/questions/51094117/dependency-cycle-detected-import-no-cycle)

8. **삭제 과정에서 오류 발견** -> 인덱싱 잘못함. 삭제 함수에서 그냥 삭제할 인덱스를 직접 정하자!
- 삭제 후 상태 업데이트가 안됨 (로컬에서는 삭제됐으나...)
- 원인은 기존 로컬 스토리지 값을 정적인 변수에 저장하느냐, 아니면 함수를 호출해서 그때그때 갱신하느냐...
- `export const stationSelector = JSON.parse(localStorage.getItem(STATION_STORAGE_NAME));` ->
  `export const stationSelector = () => JSON.parse(localStorage.getItem(STATION_STORAGE_NAME));` 로 변경

9. 일단 역 이름은 구현 완료... 일단 가장 크게 배운건 input 유효성 체크할 때 보다 깔끔하게 유지보수 편하게끔 짜는 것!


### day 5

1. null과 undefined의 차이를 정확하게 이해를 못해서, 디버깅 하는데 시간이 오래 걸렸다. (노선 길이가 2이하면 역 삭제 불가)
2. 역 삭제 시 역이 포함된 노선 중 길이가 2 이하인 노선이 하나라도 있으면 삭제 불가 처리
3. 해당 로직을, 구간 삭제 시에도 같이 사용
    - 삭제 후 새로 상태 업데이트 할 때 구간탭에서는 하나의 라인만 업데이트, 역 탭에서는 역이 포함된 모든 라인 업데이트

4. 노선도 출력은 간단해서 미리 구현함
5. 삭제 후 상태 업데이트 하는 부분은 아직 구현 안함(우선 구간 추가 데이터 포멧부터 정하기)


### day 6

1. 클래스 상속에 어느정도 익숙해져서 리팩토링 시 이 기능을 적극 활용 중.
2. selector 함수에서 map 메소드를 활용해 다시 클래스 모델로 리팩토링
    - selector 부분을 리팩토링 하는 과정에서, 형변환 후 프로그램을 돌리니 생각지도 못한 오류 발생 -> 로컬스토리지 초기화 후 해결
    - 백앤드 부분이라 이야기가 달라질 수 있겠지만, mongoDB가 형 변환이 자유롭다 보니 초보자들이 잘못 사용할 시 에러 발생할 위험이 큼

3. 표 모델은 어짜피 전부 다 중앙에서 불러온 데이터로 관리하므로, 모든 탭의 표를 하나로 통합.
    - [참고, 마지막 자식 노드만 삭제하기](https://stackoverflow.com/questions/34193751/js-remove-last-child/34193883)
4. 탭 인덱스를 상수로 만들어서 가독성도 좋고, 에디터의 도움도 더 잘 받을 수 있게 함.
5. reduce 메소드의 사용법을 다시 복습해서 더 간결하게 짬.
6. 이제 구간 추가 기능만 구현하면 완료. 딱 1주일 만에 끝낼 듯 ㅠㅠ

### day 7
1. 삭제 체크 시, 역 관리 탭에서 삭제할 것인가 아니면 구간 관리 탭에서 삭제할 것인가
    - 예외 처리 부분을 깔끔하게 반영. 생성자에서 업데이트할 노선들의 배열을 모두 저장, 그리고 해당 노선의 길이가 2이하인지 체크하는 함수 생성

2. css 업데이트, 더 리팩토링 할 거 없는지 체크
    - 뷰에서 메시지 모듈화 진행하기